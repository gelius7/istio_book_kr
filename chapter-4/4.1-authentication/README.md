---
description: 인증정책
---

# 4.1 Authentication

## Authentication

Istio는 두 가지 유형의 인증을 제공합니다.

### Peer Authentication

서비스 연결 인증에 사용 되어 클라이언트가 연결하고 있는지 확인합니다. Istio는 전송 인증을위한 풀 스택 솔루션으로 상호 TLS를 제공하며 서비스 코드 변경없이 활성화 할 수 있습니다. 이 솔루션 다음과 같은 기능을 제공합니다.

* 클러스터와 클라우드에서 상호 운용성을 가능하게하는 역할을 나타내는 강력한 ID를 각 서비스에 제공합니다.
* 서비스 간 통신을 보호합니다.
* 키 및 인증서 생성, 배포 및 회전을 자동화하는 키 관리 시스템을 제공합니다.

### Request Authentication

최종 사용자 인증에 사용 되어 요청에 첨부 된 자격 증명을 확인합니다. Istio는 JWT \(JSON Web Token\) 유효성 검사를 통해 요청 수준 인증 및 사용자 지정 인증 공급자 또는 OpenID Connect 공급자를 사용하여 간소화 된 개발자 경험을 제공합니다.

* [ORY Hydra](https://www.ory.sh/)
* [Keycloak](https://www.keycloak.org/)
* [Auth0](https://auth0.com/)
* [Firebase Auth](https://firebase.google.com/docs/auth/)
* [Google Auth](https://developers.google.com/identity/protocols/OpenIDConnect)

모든 경우에 Istio는 사용자 지정 Kubernetes API를 통해 인증 정책을 Istio 구성 저장소에 저장합니다. Istiod는 적절한 경우 키와 함께 각 프록시에 대한 최신 정보를 유지합니다. 또한 Istio는 허용 모드에서 인증을 지원하여 정책 변경이 보안 상태에 영향을 미치기 전에 보안 상태에 미치는 영향을 이해하도록 도와줍니다.

### Mutual TLS Authentication

Istio는 Envoy 프록시로 구현되는 클라이언트 및 서버 측 PEP를 통해 서비스 간 통신을 터널링합니다. 워크로드가 상호 TLS 인증을 사용하여 다른 워크로드로 요청을 보내면 요청은 다음과 같이 처리됩니다.

1. Istio는 클라이언트에서 클라이언트의 로컬 사이드카 Envoy로 아웃 바운드 트래픽을 다시 라우팅합니다.
2. 클라이언트 쪽 Envoy는 서버 쪽 Envoy와 상호 TLS 핸드 셰이크를 시작합니다. 핸드 셰이크 중에 클라이언트 측 Envoy는 보안 이름 확인을 수행하여 서버 인증서에 표시된 서비스 계정에 대상 서비스를 실행할 권한이 있는지 확인합니다.
3. 클라이언트 쪽 Envoy와 서버 쪽 Envoy는 상호 TLS 연결을 설정하고 Istio는 클라이언트 쪽 Envoy에서 서버 쪽 Envoy로 트래픽을 전달합니다.
4. 인증 후 서버 측 Envoy는 로컬 TCP 연결을 통해 트래픽을 서버 서비스로 전달합니다.

### Permissive Mode

Istio 상호 TLS에는 서비스가 일반 텍스트 트래픽과 상호 TLS 트래픽을 동시에 허용 할 수있는 허용 모드가 있습니다. 이 기능은 상호 TLS 온 보딩 경험을 크게 향상시킵니다.

비 Istio 서버와 통신하는 많은 비 Isstio 클라이언트는 상호 TLS를 사용하여 해당 서버를 Istio로 마이그레이션하려는 운영자에게 문제가 있습니다. 일반적으로 운영자는 모든 클라이언트에 대해 Istio 사이드카를 동시에 설치할 수 없거나 일부 클라이언트에 대한 권한이 없습니다. 서버에 Istio 사이드카를 설치 한 후에도 운영자는 기존 통신을 중단하지 않고 상호 TLS를 사용할 수 없습니다.

허용 모드를 사용하면 서버는 일반 텍스트 및 상호 TLS 트래픽을 모두 허용합니다. 이 모드는 온 보딩 프로세스에 더 큰 유연성을 제공합니다. 서버에 설치된 Istio 사이드카는 기존 일반 텍스트 트래픽을 방해하지 않고 즉시 상호 TLS 트래픽을 가져옵니다. 결과적으로 운영자는 클라이언트의 Istio 사이드카를 점차적으로 설치하고 구성하여 상호 TLS 트래픽을 전송할 수 있습니다. 클라이언트 구성이 완료되면 운영자는 서버를 상호 TLS 전용 모드로 구성 할 수 있습니다. 자세한 정보는 Mutual TLS Migration 튜토리얼을 방문하십시오.

### Secure Naming

서버 ID는 인증서로 인코딩되지만 서비스 이름은 감지 서비스 또는 DNS를 통해 검색됩니다. 보안 이름 지정 정보는 서버 ID를 서비스 이름에 맵핑합니다. ID A를 서비스 이름 B에 매핑하면 "A는 서비스 B를 실행할 권한이 있습니다"를 의미합니다. 컨트롤 플레인은 apiserver를 감시하고 안전한 네이밍 매핑을 생성하여 PEP에 안전하게 배포합니다. 다음 예는 인증에서 보안 이름 지정이 중요한 이유를 설명합니다.

서비스 데이터 저장소를 실행하는 합법적 인 서버가 인프라 팀 ID 만 사용한다고 가정하십시오. 악의적 인 사용자에게는 테스트 팀 ID의 인증서와 키가 있습니다. 악의적 인 사용자가 서비스를 가장하여 클라이언트에서 보낸 데이터를 검사하려고합니다. 악의적 인 사용자가 테스트 팀 ID의 인증서와 키를 사용하여 위조 된 서버를 배포합니다. 악의적 인 사용자가 \(DNS 스푸핑, BGP / 라우트 하이재킹, ARP 스푸핑 등을 통해\) 하이재킹하여 데이터 저장소로 전송 된 트래픽을 위조 된 서버로 리디렉션했다고 가정합니다.

클라이언트가 데이터 저장소 서비스를 호출하면 서버 인증서에서 테스트 팀 ID를 추출하고 안전한 이름 지정 정보로 테스트 팀이 데이터 저장소를 실행할 수 있는지 여부를 확인합니다. 클라이언트는 테스트 팀이 데이터 스토어 서비스를 실행할 수 없으며 인증이 실패 함을 감지합니다.

안전한 이름 지정은 HTTPS 트래픽에 대한 일반적인 네트워크 하이재킹을 방지 할 수 있습니다. 또한 일반적인 네트워크 하이재킹으로부터 TCP 트래픽을 보호 할 수 있습니다. 그러나 공격자는 DNS를 가로 채고 대상의 IP 주소를 수정하기 때문에 보안 이름 지정은 DNS 스푸핑으로부터 보호되지 않습니다. 이는 TCP 트래픽에 호스트 이름 정보가 포함되어 있지 않으며 라우팅을 위해 IP 주소에만 의존 할 수 있기 때문입니다. 실제로이 DNS 하이재킹은 클라이언트 쪽 Envoy가 트래픽을 받기 전에도 발생할 수 있습니다.

### Authentication Architecture

피어 및 요청 인증 정책을 사용하여 Istio 메시에서 요청을 수신하는 워크로드에 대한 인증 요구 사항을 지정할 수 있습니다. 메시 연산자는 .yaml 파일을 사용하여 정책을 지정합니다. 정책은 일단 배포되면 Istio 구성 저장소에 저장됩니다. Istio 컨트롤러는 구성 저장소를 감시합니다.

정책이 변경되면 새 정책이 PEP에 필요한 인증 메커니즘을 수행하는 방법을 알려주는 적절한 구성으로 변환됩니다. 제어 플레인은 공개 키를 페치하여 JWT 유효성 검증을위한 구성에 첨부 할 수 있습니다. 또는 Istiod는 Istio 시스템이 관리하는 키 및 인증서에 대한 경로를 제공하고 상호 TLS를 위해이를 응용 프로그램 포드에 설치합니다. PKI 섹션에서 자세한 정보를 찾을 수 있습니다.

Istio는 대상 엔드 포인트에 구성을 비동기 적으로 보냅니다. 프록시가 구성을 수신하면 새 인증 요구 사항이 해당 포드에 즉시 적용됩니다.

요청을 보내는 클라이언트 서비스는 필요한 인증 메커니즘을 따라야합니다. 피어 인증의 경우 애플리케이션은 JWT 신임 정보를 획득하여 요청에 첨부해야합니다. 상호 TLS의 경우 Istio는 두 PEP 간의 모든 트래픽을 상호 TLS로 자동 업그레이드합니다. 인증 정책이 상호 TLS 모드를 비활성화하면 Istio는 PEP간에 일반 텍스트를 계속 사용합니다. 이 동작을 무시하려면 대상 규칙과의 상호 TLS 모드를 명시 적으로 비활성화하십시오. 상호 TLS 인증 섹션에서 상호 TLS 작동 방식에 대한 자세한 내용을 확인할 수 있습니다.

![Authentication Architecture](https://github.com/istiokrsg/istio_book_kr/tree/1af2b5f9951a626f106187996fd427f6523d7102/.gitbook/assets/image-11.png)

Istio는 인증의 두 가지 유형의 인증과 해당되는 경우 자격 증명의 다른 클레임을 사용하여 다음 계층에 권한을 출력합니다.

### Authentication

이 섹션에서는 Istio 인증 정책의 작동 방식에 대한 자세한 내용을 제공합니다. 아키텍처 섹션에서 기억 하듯이 인증 정책은 서비스가받는 요청에 적용됩니다. 상호 TLS에서 클라이언트 측 인증 규칙을 지정하려면 DestinationRule에서 TLSSettings를 지정해야합니다. 자세한 내용은 TLS 설정 참조 문서를 참조하십시오.

다른 Istio 구성과 마찬가지로 .yaml 파일에서 인증 정책을 지정할 수 있습니다. kubectl을 사용하여 정책을 배포합니다. 다음 인증 정책 예제는 app : reviews 레이블이있는 워크로드에 대한 전송 인증이 상호 TLS를 사용해야 함을 지정합니다.

```text
apiVersion: "security.istio.io/v1beta1"
kind: "PeerAuthentication"
metadata:
  name: "example-peer-policy"
  namespace: "foo"
spec:
  selector:
    matchLabels:
      app: reviews
  mtls:
    mode: STRICT
```

### Policy Storage

Istio는 메쉬 네임 스페이스에 루트 네임 스페이스를 저장합니다. 이러한 정책에는 메쉬의 모든 작업 부하에 빈 선택기가 적용됩니다. 네임 스페이스 범위가있는 정책은 해당 네임 스페이스에 저장됩니다. 네임 스페이스 내의 워크로드에만 적용됩니다. 선택기 필드를 구성하면 인증 정책은 구성한 조건과 일치하는 작업에만 적용됩니다.

피어 및 요청 인증 정책은 각각 종류, PeerAuthentication 및 RequestAuthentication별로 별도로 저장됩니다.

### Selector field

피어 및 요청 인증 정책은 선택기 필드를 사용하여 정책이 적용되는 작업의 레이블을 지정합니다. 다음 예제는 app : product-page 레이블이있는 워크로드에 적용되는 정책의 선택기 필드를 보여줍니다.

```text
selector:
     matchLabels:
       app:product-page
```

선택기 필드에 값을 제공하지 않으면 Istio는 정책을 정책의 스토리지 범위에있는 모든 워크로드와 일치시킵니다. 따라서 선택기 필드는 정책 범위를 지정하는 데 도움이됩니다.

* 메시 전체 정책 : 빈 선택기 필드가 있거나없는 루트 네임 스페이스에 대해 지정된 정책입니다.
* 네임 스페이스 전체 정책 : 빈 선택기 필드가 있거나없는 루트가 아닌 네임 스페이스에 대해 지정된 정책입니다.
* 워크로드 별 정책 : 비어 있지 않은 선택기 필드를 사용하여 일반 네임 스페이스에 정의 된 정책.

피어 및 요청 인증 정책은 선택기 필드에 대해 동일한 계층 구조 원칙을 따르지만 Istio는이를 약간 다른 방식으로 결합하여 적용합니다.

네임 스페이스 당 하나의 메시 전체 피어 인증 정책과 하나의 네임 스페이스 전체 피어 인증 정책 만있을 수 있습니다. 동일한 메시 또는 네임 스페이스에 대해 여러 메시 또는 네임 스페이스 전체 피어 인증 정책을 구성하면 Istio는 최신 정책을 무시합니다. 둘 이상의 작업 부하 별 피어 인증 정책이 일치하면 Istio가 가장 오래된 것을 선택합니다.

Istio는 다음 순서를 사용하여 각 작업 부하에 대해 가장 좁은 일치 정책을 적용합니다.

1. workload-specific
2. namespace-wide
3. mesh-wide

Istio는 일치하는 모든 요청 인증 정책을 결합하여 마치 단일 요청 인증 정책에서 온 것처럼 작동 할 수 있습니다. 따라서 메시 또는 네임 스페이스에 여러 메시 전체 또는 네임 스페이스 전체 정책을 가질 수 있습니다. 그러나 메시 전체 또는 네임 스페이스 전체 요청 인증 정책이 여러 개있는 것을 피하는 것이 좋습니다.

### Peer Authentication

피어 인증 정책은 Istio가 대상 워크로드에 적용하는 상호 TLS 모드를 지정합니다. 다음과 같은 모드가 지원됩니다.

#### PERMISSIVE

워크로드는 상호 TLS와 일반 텍스트 트래픽을 모두 허용합니다. 이 모드는 사이드카가없는 워크로드가 상호 TLS를 사용할 수없는 경우 마이그레이션 중에 가장 유용합니다. 사이드카 주입으로 워크로드를 마이그레이션 한 후에는 모드를 STRICT로 전환해야합니다.

#### STRICT

워크로드는 상호 TLS 트래픽 만 허용합니다.

#### DISABLE

상호 TLS가 비활성화되었습니다. 보안 측면에서 자체 보안 솔루션을 제공하지 않으면이 모드를 사용하지 않아야합니다.

모드가 설정되지 않으면 상위 범위의 모드가 상속됩니다. 설정되지 않은 모드의 메시 전체 피어 인증 정책은 기본적으로 PERMISSIVE 모드를 사용합니다. 다음 피어 인증 정책에서는 네임 스페이스 foo의 모든 워크로드가 상호 TLS를 사용하도록 요구합니다.

```text
apiVersion: "security.istio.io/v1beta1"
kind: "PeerAuthentication"
metadata:
  name: "example-policy"
  namespace: "foo"
spec:
  mtls:
    mode: STRICT
```

위의 피어 인증 정책은 아래의 서비스 구성이 example-app 작업의 요청을 example-service의 포트 80으로 바인딩했기 때문에 작동합니다.

```text
apiVersion: v1
kind: Service
metadata:
  name: example-service
  namespace: foo
spec:
  ports:
  - name: http
    port: 8000
    protocol: TCP
    targetPort: 80
  selector:
    app: example-app
```

### Request Authentication

요청 인증 정책은 JSON 웹 토큰 \(JWT\)의 유효성을 검증하는 데 필요한 값을 지정합니다. 이러한 값에는 다음이 포함됩니다.

* 요청메시지 토큰의 위치
* 발급자 또는 요청
* 공개 JSON 웹 키 세트 \(JWKS\)

Istio는 요청 인증 정책의 규칙에 대해 제시된 경우 제시된 토큰을 확인하고 유효하지 않은 토큰이있는 요청을 거부합니다. 요청에 토큰이 없으면 기본적으로 수락됩니다. 토큰이없는 요청을 거부하려면 특정 작업 \(예 : 경로 또는 작업\)에 대한 제한을 지정하는 권한 부여 규칙을 제공하십시오.

요청 인증 정책은 각각 고유 한 위치를 사용하는 경우 둘 이상의 JWT를 지정할 수 있습니다. 둘 이상의 정책이 작업 부하와 일치하면 Istio는 모든 규칙을 마치 단일 정책으로 지정된 것처럼 결합합니다. 이 동작은 다른 제공자로부터 JWT를 승인하도록 워크로드를 프로그래밍하는 데 유용합니다. 그러나 해당 요청의 출력 주체가 정의되지 않았기 때문에 둘 이상의 유효한 JWT를 가진 요청은 지원되지 않습니다.

### Principals

피어 인증 정책과 상호 TLS를 사용하면 Istio는 피어 인증에서 ID를 source.principal로 추출합니다. 마찬가지로 요청 인증 정책을 사용할 때 Istio는 JWT의 ID를 request.auth.principal에 할당합니다. 이 원칙을 사용하여 권한 부여 정책을 설정하고 원격 분석 출력으로 설정하십시오.

* 모드를 DISABLE에서 STRICT로 또는 그 반대로 변경할 때 PERMISSIVE 모드를 사용하는 중간 피어 인증 정책을 사용하십시오. 모든 작업이 원하는 모드로 성공적으로 전환되면 최종 모드로 정책을 적용 할 수 있습니다. Istio 원격 측정을 사용하여 작업 부하가 성공적으로 전환되었는지 확인할 수 있습니다.
* 한 JWT에서 다른 JWT로 피어 인증 정책을 마이그레이션 할 때 이전 규칙을 제거하지 않고 새 JWT에 대한 규칙을 정책에 추가하십시오. 그런 다음 워크로드는 두 유형의 JWT를 모두 허용하며 모든 트래픽이 새 JWT로 전환 될 때 기존 규칙을 제거 할 수 있습니다. 그러나 각 JWT는 다른 위치를 사용해야합니다.

