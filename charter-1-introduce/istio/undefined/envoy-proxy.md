# Envoy

엔보이\(Envoy Proxy, 이하 엔보이\)는 서비스 매쉬 구조에서 특정 서비스에서 발생하는 모든 인/아웃 바운드 트래픽을 제어할 수 있는 개발된 고성능 프록시 서버입니다. 이스티오에서는 확장된 버전의 엔보이를 사이드카 카 패턴으로 배포하여, 서비스의 요청자와 처리자의 중간에서 프록시를 두도록 구성합니다.

![](../../../.gitbook/assets/image%20%288%29.png)

이렇게 서비스의 모든 입출력 트래픽을 받도록 구성하여, 해당 트래픽을 처리하기 때문에 이스티오는 아래와 같이 당양한 트래픽 제어 기능을 제공할 수 있습니다. 

`동적인 서비스 디스커버리(dynamic service discovery)  
로드 밸런싱  
TLS 종료  
HTTP/2 와 gRPC 프록시  
서킷 브레이크  
헬스 체크  
스테이지된 롤링 및 퍼센트 기반 트래픽 분리  
장애 주입  
다양한 지표`  
  
  
언급한 트래픽 제어 기능에 대해서 알아 봅시다.

### Dynamic Service Discovery

![](../../../.gitbook/assets/image%20%2810%29.png)

MSA 구조에서 각 서비스 상호간 API 호출을 위해서는 상대방 서비스에 대한 IP 주소를 알아야 합니다. 클라우드 또는 Kubernetes 클러스터와 같은 환경에서는 서비스가 배포될 때마다 IP 가 동적으로 변경될 수 있기 때문에 특정 서비스와의 연동을 위해서는 해당 서비스에 대한 위치 즉, IP를 조회할 수 있는 서비스 디스커버리\(Service Discovery\) 기능이 필요합니다.

Istio는 Pilot을 통해 Service Discovery 를 제공합니다. Dynamic Service Discovery 를 위해 Istio Pilot 아키텍처에 대한 이해가 먼저 필요합니다. Kubernetes, Mesos, CloudFoundry 등 클러스터에 배포된 각 서비스들은 다른 서비스들을 호출할때, 상대편의 IP 또는 도메인 URL 정보를 알아야 합니다. envoy 가 특정 서비스의 Endpoint IP 주소를 조회하기 위해, Control Plane의 Pilot은 Service Mesh 에 등록된 모든 서비스에 대한 엔드포인트 정보를 저장/관리하고, 조회할 수 있는 기능을 제공합니다.

![](../../../.gitbook/assets/image%20%2815%29.png)

Service Mesh 안에 배포된 각 서비스들은 다른 서비스들을 호출할때, 상대편의 IP 또는 도메인 URL 정보를 알아야 합니다. envoy 가 특정 서비스의 Endpoint IP 주소를 조회하기 위해, Control Plane의 Pilot은 Service Mesh 에 등록된 모든 서비스에 대한 엔드포인트 정보를 저장/관리하고, 조회할 수 있는 기능을 제공합니다. 위 그림과 같이 Service A와 B가 배포되고, 이후 Service Discovery 과정을 거쳐서 상호 통신하는 과정을 살펴보겠습니다.

Service Discovery 과정

1. 새로운 Service B 가 Sidecar Pattern 을 통해 Envoy 와 함께 배포되고, 서비스 실행시 Pilot의 Platform Adapter에게 서비스 등록을 알림
2. Platform Adapter는 서비스 인스턴스를 Abstract Model 에 등록
3. Pilot은 트래픽 제어를 위한 구성과 규칙정보를 Envoy 에게 전송 

MSA 와 같은 분산 환경에서는 서비스 간의 API 호출이 필요합니다.

### Load Balancing

로드 밸런싱은, 부하가 고르게 퍼지도록 하여 서비스의 안정성을 유지할 수 있도록 하는 기능입니다. 요청이 한쪽 서비스 인스턴스에 몰리지 않도록 배분을 잘 해야 합니다. 쿠버네티스의 레이블일 이용하여, 요청자와 가까운 지역별로 혹은 지역이나 서비스별 가중치를 두어서 라우팅하도록 구성할 수 있습니다. 

### TLS Termination

오늘날 대부분의 웹 트래픽은 HTTP 보다는 HTTPS 을 기본으로 사용합니다. 일부 트래픽이 외부에 노출이 되어도 트래픽은 모두 TLS 방식으로 암호화되어 있어서, 내용을 알아 볼 수 없도록 하여 보안성을 확보해야 하기 떄문입니다.

위의 그림은 이스티오 내에 프록시의 일반적인 동작을 설명합니다. 흐름을 보면, 1번에서 클라이언트에서 보낸 암호화된 트래픽을 프록시가 받았습니다. 이 트래픽을 익스터널 인바운드 트래픽이라 하겠습니다. 그럼 2번으로 서비스에 해당 트래픽을 보내주기 전에 암호화된 것을 풀어서 보내줄지 아니면 그대로 보내줄지에 대한 결정을 해야 합니다. 이 트래픽은 로컬 인바운드 트래픽이라 하겠습니다.  
그런데 문제는 암호화하였기 때문에, 익스터널 인바운드 트래픽을 복호화 하기 위해서 암호학 연산을 수행해야 한다는 것입니다. 물론 익스터널 인바운드 트래픽이 얼마 되지 않는다면 문제가 없겠습니다. 그러나 일반적으로 프로덕션에서는 그렇지 않습니다. 따라서 복호화를 위해 프록시 뿐만 아니라 서비스에서도 동일한 암호학 연산을 수행해야 하고, 그러면 프록시와 서비스 모두 복호화를 위한 컴퓨팅 자원을 필요로 하게 됩니다. 물론 보안이 극도로 요구되는 경우라면, 이런 구성이 필요할 수도 있습니다. 그러나 일반적으로는 MSA 관점으로 생각해본다면, 굳이 내부에 있는 서비스에 복호화의 짐을 지워줄 필요는 없습니다. 프록시를 TLS 에 대한 검증과 복호화를 수행하는 일종의 마이크로 서비스로 볼 수 있습니다. 인보이를 이용하여 TLS 단계를 끊어주는 처리를 해줄 수 도 있습니다. 응답을 줄 때에도 로컬 아웃바운드의 트래픽을 프록시가 받아서, 클라이언트에게 응답을 거나 다른 내외부 서비스에 요청을 보낼 수도 있습니다.

내부적인 트래픽은 mTLS 형식으로 안전하게 주고 받을 수 있으며, 기존 서비스를 전혀 수정하지 않고도 이스티오 수정만으로 가능하게 됩니다.

### HTTP/2 와 gRPC 프록시

비단 HTTP/2 나 gRPC 의 프록시 역할 이외에도 MySQL, redis, mongo, tcp, udp 같은 다양한 프로토콜의 프록시 역할을 할 수 있습니다. 이외의 프로토콜의 프록시를 필요로 한다면, 원하는 프로토콜을 처리하는 핸들러 웹어셈블리 모듈을 만들어서 등록 사용할 수 있습니다.

### 서킷 브레이커\(Circuit Breaker\)

서킷 브레이커는 트래픽 누전 차단기와 같다고 보면 됩니다. 누전되었을 때에, 계속 전기를 흐르게 하면 큰 사고가 날 수 있어서 차단해 주는 것처럼, MSA 구조에서 장애가 발생하여 더이상 요청을 처리할 수 없는 서비스를 놔두는 것은 장애를 확산하는 일에 불가합니다. 이럴 경우, 재빨리 서비스 연결을 끊어서 장애를 줄이는 것이 급선무인데요. 이런 서비스 처리 흐름을 끊는 작업을 서킷 브레이커라 합니다.

### 헬스 체크

서비스가 정상적인지 정상적이지 않은 지를 주기적으로 확인해 주는 역할을 해줍니다. 쿠버네티스의 probe 와 비슷하지만, 

### 비율 단위 트래픽 분리를 통한 롤링 스테이징

프록시에서는 트래픽의 흐름을 제어할 수 있기 때문에, 트래픽 양을 원하는 기준에 맞춰 어느 서비스로 보낼지를 제어할 수도 있습니다. 비율별 혹은 상태별로 트래픽 양과 대상을 조절할 수 있습니다.

### 장애 주입\(Fault Injection\)

프록시를 이용하여 장애 트래픽을 주입해볼 수 있습니다. 거짓 응답을 주거나, 지연이나, 패킷 손실 등에 실제 존재할 수 있는 장애를 실험해 볼 수 있습니다.

### 다양한 지표 제공

앞서 HTTP/2, gRPC 프락시 역할을 수행할 수 있다고 한 부분에서 알 수 있듯이, 기본적으로 제공하는 지표들이 있고, 원하는 지표가 있으면 해당 지표를 측정하고 수집하고 모듈을 만들 수 있고 이를 쉽게 적용할 수있는 구조로 되어 있습니다. 각각의 프록시 수준에서 얻을 수 있는 다운/업스트림 트래픽 통계, 장애빈도 등이 기본적으로 제공합니다. 일반적으로 엔보이에서 제공하는 통계를 그대로 제공합니다.

