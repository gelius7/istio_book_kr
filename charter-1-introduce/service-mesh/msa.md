# 마이크로서비스 아키텍처

MSA는 기존의 전통적인 모노리식 아키텍처에서 벗어나 하나의 큰 애플리케이션을 분리 가능한 모듈로 나누어 여러개의 애플리케이션으로 나누어 변경과 조합이 가능하도록 만든 아키텍처 입니다. 각각의 MSA는 독립적으로 동작할 수 있어야 하고, 여러 다른 마이크로서비스와 연동하여 하나의 독립된 서비스를 제공할 수 있어야 합니다.

마이크로서비스 아키텍처의 등장배경을 살펴보려면 기존 모노리식과 MSA 의 장단점을 살펴볼 필요가 있습니다.

![](../../.gitbook/assets/image%20%2826%29.png)

## Monolithic Architecture

Monolithic Architecture는 서비스에 필요한 모든 로직이 하나의 프로세스로 통합되어 실행되는 구조입니다. 과거 많은 프로젝트가 Monolithic 방식으로 개발되어 왔고, 소규모 프로젝트 환경에서는 간단한 아키텍처 기반으로 빠르게 주요 아이디어를 검증/개발하고, 유지보수하기 효율적이었습니다. 하지만 빅데이터 시대에 처리해야 할 데이터의 종류와 사이즈가 커지고, 이를 처리하기 위한 컴퓨팅 파워의 필요성이 증가하게 되면서 Monolithic Architecture는 한계를 가지고 있습니다.

### Monolithic Architecture 장점

* 서비스 실행 환경이 어디든 동일하고, 단순함
* 동일한 애플리케이션을 여러개 생성하여 고가용 서버 환경을 쉽게 생성
* E2E\(End-to-End\) 테스트 용이

### Monolithic Architecture 단점

* 프로젝트 규모가 커질수록, 특정 모듈의 전체 시스템에서의 성능영향, 구조 파악이 어려움
* 빌드/배포 시간이 기능이 추가될때마다 기하급수적으로 증가
* 특정 서비스에 대해서만 sacle-out 어려움
* 특정 모듈의 장애가 서비스 전체 장애로 확대

## MSA\(Micro Service Architecture\)

MSA 는 기존 Monolithic Architecture 안에 있는 통합된 모든 기능들을 스스로 돌아갈 수 있는 작은 단위의 서비스로 분리하고, 이를 독립적인 배포가 가능한 모듈로 분리하여 서비스가 가능한 아키텍처를 구성합니다. 여기서 의미하는 스스로 돌아갈 수 있는 작은 단위의 의미는 다른 서비스에 대한 의존성이 최소화 되어야 하고, 서비스 간의 REST API 와 같은 가벼운 통신 방식을 통해 연동 가능해야 하고, 개발자의 역량과 모듈에 특화된 개발환경을 통해 독립적인 서비스가 가능해야 함을 의미합니다. 이러한 MSA 아키텍처의 개발 철학은 Cloud Natvive 와 같은 유연한 인프라 환경에서 각 여러 분야의 개발자들이 독립적으로 로직을 설계/개발하고, 기능을 확장해 나감으로써 새로운 비지니스 모델에 유연하고 빠르게 대응할 수 있는 환경을 가능하도록 했습니다. 따라서 기존 Monolithic Legacy 를 MSA 기반으로 마이그레이션 하기 위해서는 다음과 같은 검토 사항이 필요합니다.

### MSA 적용 검토사항

* 스스로 동작할 수 있는 작은 단위의 서비스로 분리 가능해야 함.
* 독립적인 배포가 가능해야 함
* 각 마이크로 서비스는 다른 서비스에 대한 의존성이 최소화 되어야 함
* 각 마이크로 서비스 간 통신은 REST API 와 같은 가벼운 통신이어야 함

일반적으로 하나의 서비스는 전체 서비스 측면에서 일부 기능일 수 있으며, 하나의 프로젝트로 볼 수 있습니다. 비지니스 모델과 이를 지탱하기 위한 인프라의 여건에 따라 서비스의 범위와 마이크로 서비스 단위로 나누는 전략이 무엇보다 중요합니다. 따라서 기존 Monolithic Architecure 기반의 서비스를 무조건 MSA 구조로 마이그레이션 하는 것은 올바르지 않으며, MSA의 장단점을 인지하고 적용여부를 검토하는 것이 중요합니다.

### MSA 장점

#### SOA\(Service Oriented Architecture\)

MSA는 스스로 동작할 수 있는 작은 단위의 서비스로 분리하고, MSA 간의 통신은 RestAPI를 통해서만 상호 연동할 수 있어야 합니다. 즉,  MSA는 end-point url을 외부 API 서비스 형태로 외부에 노출하고, 그 안에서 동작하는 세부 로직, 아키텍처, 개발언어와 같은 기술사항들은 API 서비스에 의해 가려집니다. 이를 통해 개발자는 서비스 개발에 필요한 구체적인 기술들을 자유롭게 설계/개발할 수 있습니다.

#### 복잡도 감소

MSA 는 독립적인 서비스 모듈화를 통해 팀 또는 개인별 서비스 개발을 빠르게 하며, 유지보수가 가능합니다. 이를 통해 모노리식과 같이 모든 서비스 모듈이 하나로 통합되어 있는 구조에서는 각 모듈의 구성을 소스 내에서 이해하기 쉽지 않기 때문에 유지보수 하기 어렵습니다. 하지만 반대로 너무 많은 MSA 가 생성될 경우 이를 관리하기 위한 복잡도가 발생할 수 있습니다. 따라서 MSA 검토시 각 서비스 환경에 맞는 전략적인 MSA 아키텍처링이 필요합니다.

#### 개별 배포 자동화 

마이크로서비스는 개별 독립적인 배포가 가능합니다. 따라서 지속적인 코드 통합/배포 \(Continuous Integration / Continuous Deployment\)를 통해 배포 자동화 가능합니다. 모노로식에 비해 가볍기 때문에 빠른 배포 가 가능합니다.

#### 스케일링

MSA 는 쿠버네티스 클러스터와 같은 대용량 분산 환경에 적합한 구조입니다. 각 마이크로서비스를 Containeration 하여 만들어진 컨테이너를 쿠버네티 환경에서 오케스트레이션 할 수 있습니다. 이 과정에서 특정 마이크로 서비스 부하에 따라 컨테이너 단위 스케일링\(Scale-In/out\) 이 가능합니다. 또한 클러스터 전체에서 사용 가능한 리소스\(cpu, memory\) 중에 특정 마이크로서비스의 리소스 설정이 가능하기 때문에 모노리식 스케일링에 비해 리소스를 효율적으로 절약 관리할 수 있습니다.

#### 서비스 전체 장애 확대 방지

모로리식의 경우 특정 모듈의 장애가 서비스 전체 장애로 이어집니다. 소스코드에 대한 버그가 원인일 수도 있지만, 서비스 트래픽이 증가하면서 특정 모듈에서 발생하는 부하 문제가 성능 장애로 어이지는 경우가 많습니다. 마이크로서비스는 독립적으로 배포하여 실행 가능한 구조이기 때문에 특정 마이크로서비스에서 발생한 장애가 시스템 전체의 장애로 확대되지 않습니다. 서비스 트래픽에 증가에 따른 유연한 스케일링이 가능하고, 소스 코드에 대한 버그 발생시 수정후 빠른 개별 배포가 가능합니다. 

### MSA 단점

아이러니 하게도 MSA 의 장점을 제대로 이해하고 활용하지 못하는 경우 모든 것이 단점으로 작용할 수 있습니다. 그 이유를 살펴보겠습니다.

#### 복잡성 증가

MSA 는 독립적으로 배포 가능한 각 서비스 단위로 분리하기 때문에 모노리식에 비해 관리해야 할 서비스의 복잡도가 증가합니다. 팀별 내부 마이크로서비스 간 API 통신을 이용한 연동 협의가 필요합니다. 또한 트래픽 부하가 발생할 경우 비지니리 로직에 대한 트랜잭션을 어떻게 유지할지에 대한 많은 고민과 의사결정이 필요합니다.

#### 트랜잭션 유지 어려움

서비스는 일관된 데이터 트랜잭션을 유지하는 것이 무엇보다 중요합니다. 모노리식은 단일 트랜잭션\(DB\) 를 유지하면 되지만, 각 마이크로서비스는 독립적으로 분산 배포되고, 별도의 비지니스 DB 트랜잭션 로직을 가지고 있기 때문에 API 를 통한 서비스 연결이 되어 전체 일관된 트랜잭션을 유지가 어렵습니다.



 또한 서비스가 대용량 분산 시스템에서 개별 배포되어 운영되기 때문에 비지니스 로직의 트랜잭션을 유지하는 것이 어렵습니다. 

